[
    {
        "path": "C:\\Users\\kizer\\Master's project\\CDD.py",
        "name": "CDD.py",
        "content": "import numpy as np\nimport scipy.signal\nimport math\n\ndef compute_curvature(u):\n    \"\"\"\n    Compute the curvature of the image u.\n    \"\"\"\n    # Compute gradients (creating arrays filled with gradients of the image values in each direction)\n    u_x = np.gradient(u, axis=1)\n    u_y = np.gradient(u, axis=0)\n\n    # Compute gradient magnitude \n    magnitude = np.sqrt(u_x**2 + u_y**2) + 1e-8  # Added small constant to avoid division by zero\n\n    # Compute curvature\n    curvature = np.gradient(u_x/magnitude, axis=1) + np.gradient(u_y/magnitude, axis=0) \n    return curvature\n\ndef cdd_inpainting(image, mask, g, iterations=100, tau=0.1):\n    \"\"\"\n    Performs Curvature-Driven Diffusions (CDD) inpainting on a given image.\n    \n    Parameters:\n        image: 2D numpy array representing the grayscale image.\n        mask: 2D boolean numpy array where True indicates missing pixels to inpaint.\n        g: Function that modifies diffusion based on curvature.\n        iterations: Number of iterations to run the inpainting process.\n        tau: Time step size.\n        \n    Returns:\n        Inpainted image as a 2D numpy array.\n    \"\"\"\n    u = image.astype(np.float64)  # Convert image to float for processing\n    \n    for iter_num in range(iterations):\n        curvature = compute_curvature(u)\n        # Compute gradient magnitude \n        magnitude = np.sqrt(np.gradient(u, axis=1)**2 + np.gradient(u, axis=0)**2) +1e-8\n        D = g(np.abs(curvature))/magnitude\n\n        # Compute j , the flux field\n        j_x = -D*np.gradient(u, axis=1)\n        j_y = -D*np.gradient(u, axis=0)\n        \n        # Compute the divergence\n        divergence = np.gradient(j_x, axis=1) + np.gradient(j_y, axis=0)\n        \n        # Update only the inpainting domain\n        u[mask] -= tau * divergence[mask]\n        \n        # Debugging: print the iteration number and max divergence\n        if iter_num % 100 == 0 or iter_num == iterations - 1:\n            print(f\"Iteration {iter_num + 1}/{iterations}, max divergence: {np.max(divergence)}\")\n    \n    # Convert the processed image back to the original type\n    u = np.clip(u, 0, 255)  # Clip values to be in the valid range\n    u = u.astype(image.dtype)\n    return u"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\efficiency.py",
        "name": "efficiency.py",
        "content": "import numpy as np\n\ndef mse(imageA, imageB):\n    # Calculate Mean Squared Error (MSE) between two images\n    # MSE is the sum of the squared difference between the two images divided by the total number of pixels\n    err = np.sum((imageA.astype(\"float\") - imageB.astype(\"float\")) ** 2)\n    err /= float(imageA.shape[0] * imageA.shape[1])\n    \n    return err\n\n\n#CHANGE TO JUST THE MASK \ndef psnr(original, restored):\n    # Calculate Peak Signal-to-Noise Ratio (PSNR) between original and restored images\n    mse_value = mse(original, restored)\n    if mse_value == 0:\n        # If MSE is 0, it means no error, return maximum value\n        return 100\n    max_pixel = 255.0\n    psnr_value = 20 * np.log10(max_pixel / np.sqrt(mse_value))\n    return psnr_value\n\nfrom skimage import io"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Index.py",
        "name": "Index.py",
        "content": "from Nonlinear_diff import *\nfrom CDD import *\nfrom efficiency import *\nfrom PIL import Image\nfrom skimage import color\nfrom skimage.color import rgb2gray\nfrom skimage import io, img_as_ubyte\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom TV import *\nfrom skimage.filters import gaussian\nimport cv2\n\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    mask = np.zeros(image.shape, dtype=bool)\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Function to generate a mask with Gaussian noise exceeding a threshold\ndef generate_gaussian_noise_mask(image, noise_level=0.1, threshold_factor=1.0):\n    # Generate Gaussian noise\n    noise = np.random.normal(0, noise_level, image.shape)\n    \n    # Calculate threshold based on noise level and factor\n    threshold = noise_level * threshold_factor\n    \n    # Create a boolean mask where the noise exceeds the threshold\n    mask = np.abs(noise) > threshold\n    \n    return mask\n\n# Function to generate a mask with random pixels set to 0\ndef generate_random_pixel_mask(image, mask_ratio=0.1):\n    # Create a mask with the same shape as the image, initialized to False\n    mask = np.zeros(image.shape, dtype=bool)\n    # Calculate the number of pixels to be masked\n    num_pixels = image.size\n    num_masked_pixels = int(num_pixels * mask_ratio)\n    # Randomly choose indices to set to 0\n    indices = np.random.choice(num_pixels, num_masked_pixels, replace=False)\n    # Set the chosen indices in the mask to True\n    mask.flat[indices] = True\n    return mask\n\n# Load the images\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with a small square in the middle\nmask = generate_square_mask(gray_image, square_size=50)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Apply the mask (highlight masked areas in red for visibility)\ngray_image_rgb = np.stack([gray_image]*3, axis=-1)\ngray_image_rgb[mask] = [1, 0, 0]  # Red color for masked areas\nprint(\"mse = \", mse(gray_image, masked_image))\nprint(cv2.PSNR(gray_image, masked_image))"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Nonlinear_diff.py",
        "name": "Nonlinear_diff.py",
        "content": "import math\nimport skimage\nimport numpy as np\nimport scipy.signal\nfrom skimage.util import random_noise\n\n# Function to generate a mask with random noise\ndef generate_mask(image, noise_amount=0.2):\n    \"\"\"\n    Generate a mask with random noise based on the input image.\n    \"\"\"\n    noisy_image = random_noise(image, mode='s&p', amount=noise_amount)\n    mask = noisy_image != image\n    return mask\n\ndef nonlinearDiffusionFilter(image: np.ndarray, iterations=5, lamb=1.0, tau=0.125, image_seq=None):\n    \"\"\"\n    Execute nonlinear isotropic smoothing filter on an image.\n    The method is based on the 1990 paper by Perona and Malik.\n    This smoothing method uses diffusion that preserves edges.\n    \"\"\"\n    def computeUpdate(u: np.ndarray, g: np.ndarray):\n        \"\"\"\n        Compute the update for the next iteration using spatial derivatives.\n        \"\"\"\n        update = np.zeros(u.shape, dtype=float)\n        u_padded = np.pad(u, pad_width=1, mode='constant')\n        g_padded = np.pad(g, pad_width=1, mode='constant')\n\n        for i in range(1, u_padded.shape[1]-1):\n            for j in range(1, u_padded.shape[0]-1):\n                g_pj = math.sqrt(g_padded[j, i+1] * g_padded[j, i])\n                g_nj = math.sqrt(g_padded[j, i-1] * g_padded[j, i])\n                g_ip = math.sqrt(g_padded[j+1, i] * g_padded[j, i])\n                g_in = math.sqrt(g_padded[j-1, i] * g_padded[j, i])\n\n                if i==u.shape[1]-2:\n                    g_pj = 0\n                if i==1:\n                    g_nj = 0\n                if j==u.shape[0]-2:\n                    g_ip = 0\n                if j==1:\n                    g_in = 0\n\n                ux0 =  g_pj * (u_padded[j, i+1] - u_padded[j, i])\n                ux1 = -g_nj * (u_padded[j, i] - u_padded[j, i-1])\n                uy0 =  g_ip * (u_padded[j+1, i] - u_padded[j, i])\n                uy1 = -g_in * (u_padded[j, i] - u_padded[j-1, i])\n\n                # Update is not padded, so subtract 1 from indices\n                update[j-1, i-1] = ux0 + ux1 + uy0 + uy1\n\n        return update\n\n    def computeDiffusivity(u: np.ndarray, lamb: float):\n        \"\"\"\n        Compute the nonlinear gradient-derived diffusivity.\n        \"\"\"\n        shape = u.shape\n        if len(shape) > 2 and shape[2] > 1:\n            print(\"RGB to gray\")\n            u = skimage.color.rgb2gray(u)\n    \n        gradkernelx = 0.5 * np.array([[0.0, 0.0, 0.0], \n                                      [-1.0, 0.0, 1.0], \n                                      [0.0, 0.0, 0.0]])\n        gradkernely = 0.5 * np.array([[0.0, -1.0, 0.0], \n                                      [0.0, 0.0, 0.0], \n                                      [0.0, 1.0, 0.0]])\n        gradx = scipy.signal.convolve2d(u, gradkernelx, boundary='symm')\n        grady = scipy.signal.convolve2d(u, gradkernely, boundary='symm')\n        gradm2 = np.square(gradx) + np.square(grady)\n        g = 1.0 / (np.sqrt((1.0 + gradm2) / (lamb*lamb)))\n        return g\n\n    u = np.copy(image)\n    if len(u.shape) > 2 and u.shape[2] == 1:\n        u = np.reshape(u, (u.shape[0], u.shape[1]))\n    if image_seq is not None:\n        image_seq.append(np.copy(u))\n\n    for i in range(iterations):\n        print(f\"Iterations: {i+1}/{iterations}\")\n        g = computeDiffusivity(u, lamb)\n        update = computeUpdate(u, g)\n        u += tau * update\n        if image_seq is not None:\n            image_seq.append(np.copy(u))\n    return u"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Optimization_CDD.py",
        "name": "Optimization_CDD.py",
        "content": "```python\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    # Calculate the center coordinates of the image\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    # Create a mask with a square region in the middle\n    mask = np.zeros(image.shape, dtype=bool)\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Parameters for optimization\ntau_values = np.linspace(0.001, 0.1, 100)  # 100 values between 0.001 and 0.1\np_values = range(1, 11)  # Integer values from 1 to 10\n\nbest_psnr = 0\nbest_mse = float('inf')\nbest_tau = 0\nbest_p = 0\n\n# Load the original image and convert it to grayscale\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with a small square in the middle\nmask = generate_square_mask(gray_image, square_size=20)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Iterate over tau and p values to find the best combination\nfor tau in tqdm(tau_values, desc='Tau Iterations'):\n    for p in tqdm(p_values, desc='P Iterations', leave=False):\n        # Define the g function based on curvature\n        g = lambda s: s**p\n        \n        # Inpaint the image using CDD algorithm\n        inpainted_image = cdd_inpainting(masked_image, mask, g, iterations=2500, tau=tau)\n        \n        # Calculate PSNR between original and inpainted image\n        psnr_value = cv2.PSNR(gray_image, inpainted_image)\n        \n        # Calculate MSE between original and inpainted image\n        mse_value = mse(gray_image, inpainted_image)\n        \n        # Check if current combination is better than the previous best\n        if psnr_value > best_psnr or (psnr_value == best_psnr and mse_value < best_mse):\n            best_psnr = psnr_value\n            best_mse = mse_value\n            best_tau = tau\n            best_p = p\n            print(f\"New Best PSNR: {best_psnr} dB, MSE: {best_mse}, Tau: {best_tau}, P: {best_p}\")\n\n# Print the best parameters found\nprint(f\"Best Tau: {best_tau}, Best P: {best_p}\")\nprint(f\"Best PSNR: {best_psnr} dB, Best MSE: {best_mse}\")\n\n# Generate the best inpainted image using the optimal parameters\ng = lambda s: s**best_p\nbest_inpainted_image = cdd_inpainting(masked_image, mask, g, iterations=5000, tau=best_tau)\n\n# Display original grayscale image and best inpainted image\nfig, axes = plt.subplots(1, 2, figsize=(15, 5))\naxes[0].imshow(masked_image, cmap='gray')\naxes[0].set_title('Original Grayscale Image')\naxes[0].axis('off')\n\naxes[2].imshow(best_inpainted_image, cmap='gray')\naxes[2].set_title('Best Inpainted Image')\naxes[2].axis('off')\n\nplt.show()\n```"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Optimization_NDF.py",
        "name": "Optimization_NDF.py",
        "content": "```python\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    # Calculate center coordinates of the image\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    # Create a mask with a square centered in the image\n    mask = np.zeros(image.shape, dtype=bool)\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Parameters for optimization\niterations_values = range(1, 21)  # Vary number of iterations from 1 to 20\nlamb_values = np.linspace(0.1, 2.0, 10)  # 10 values between 0.1 and 2.0\ntau = 0.125  # Fixed tau\n\nbest_psnr = 0\nbest_mse = float('inf')\nbest_iterations = 0\nbest_lamb = 0\n\n# Load the original image and convert it to grayscale\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with Gaussian noise\nmask = generate_gaussian_noise_mask(gray_image, noise_level=0.1, threshold_factor=1.5)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Iterate over different combinations of iterations and lambda values\nfor iterations in tqdm(iterations_values, desc='Iterations Loop'):\n    for lamb in tqdm(lamb_values, desc='Lambda Iterations', leave=False):\n        # Inpaint the image using nonlinear diffusion filter\n        inpainted_image = nonlinearDiffusionFilter(masked_image, iterations=iterations, lamb=lamb, tau=tau)\n        \n        # Calculate PSNR (Peak Signal-to-Noise Ratio)\n        psnr_value = cv2.PSNR(gray_image, inpainted_image)\n        \n        # Calculate MSE (Mean Squared Error)\n        mse_value = mse(gray_image, inpainted_image)\n        \n        # Check if the current combination is better than the previous best\n        if psnr_value > best_psnr or (psnr_value == best_psnr and mse_value < best_mse):\n            best_psnr = psnr_value\n            best_mse = mse_value\n            best_iterations = iterations\n            best_lamb = lamb\n            print(f\"New Best PSNR: {best_psnr} dB, MSE: {best_mse}, Iterations: {best_iterations}, Lambda: {best_lamb}\")\n\n# Print the best parameters found during optimization\nprint(f\"Best Iterations: {best_iterations}, Best Lambda: {best_lamb}\")\nprint(f\"Best PSNR: {best_psnr} dB, Best MSE: {best_mse}\")\n\n# Optionally, visualize the best inpainting result\nbest_inpainted_image = nonlinearDiffusionFilter(masked_image, iterations=best_iterations, lamb=best_lamb, tau=tau)\n\n# Display the masked image and the best inpainted image side by side\nfig, axes = plt.subplots(1, 2, figsize=(15, 5))\naxes[0].imshow(masked_image, cmap='gray')\naxes[0].set_title('Masked Image')\naxes[0].axis('off')\n\naxes[1].imshow(best_inpainted_image, cmap='gray')\naxes[1].set_title('Best Inpainted Image')\naxes[1].axis('off')\n\nplt.show()\n```"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Optimization_TV.py",
        "name": "Optimization_TV.py",
        "content": "```python\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    # Calculate the center coordinates of the image\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    # Create a mask with a square region in the middle\n    mask = np.zeros(image.shape, dtype=bool)\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Parameters for optimization\nlambda_values = np.linspace(1.0, 10, 10)\nT = 2500\ndt = 0.5\n\nbest_psnr = 0\nbest_mse = float('inf')\nbest_lambda = 0\n\n# Load the original image and convert it to grayscale\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with a small square in the middle\nmask = generate_square_mask(gray_image, square_size=20)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Iterate over lambda values with progress bar\nfor lambda_val in tqdm(lambda_values, desc='Lambda Iterations'):\n    # Inpaint the masked image using Total Variation method\n    inpainted_image, _ = TV(masked_image, lambda_val, mask, T, dt)\n    \n    # Calculate Peak Signal-to-Noise Ratio (PSNR)\n    psnr_value = cv2.PSNR(gray_image, inpainted_image)\n    \n    # Calculate Mean Squared Error (MSE)\n    mse_value = mse(gray_image, inpainted_image)\n    \n    # Update best parameters if current combination is better\n    if psnr_value > best_psnr or (psnr_value == best_psnr and mse_value < best_mse):\n        best_psnr = psnr_value\n        best_mse = mse_value\n        best_lambda = lambda_val\n        print(f\"New Best PSNR: {best_psnr} dB, MSE: {best_mse}, Lambda: {best_lambda}\")\n\n# Print the best parameters found\nprint(f\"Best Lambda: {best_lambda}\")\nprint(f\"Best PSNR: {best_psnr} dB, Best MSE: {best_mse}\")\n\n# Optionally, visualize the best inpainted result\nbest_inpainted_image, _ = TV(masked_image, best_lambda, mask, T, dt)\nbest_inpainted_image_normalized = (best_inpainted_image - np.min(best_inpainted_image)) / (np.max(best_inpainted_image) - np.min(best_inpainted_image))\nbest_inpainted_image_uint8 = img_as_ubyte(best_inpainted_image_normalized)\n\n# Display the masked image and the best inpainted image side by side\nfig, axes = plt.subplots(1, 2, figsize=(15, 5))\naxes[0].imshow(masked_image, cmap='gray')\naxes[0].set_title('Masked Image')\naxes[0].axis('off')\n\naxes[1].imshow(best_inpainted_image_uint8, cmap='gray')\naxes[1].set_title('Best Inpainted Image')\naxes[1].axis('off')\n\nplt.show()\n```"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\README.md",
        "name": "README.md",
        "content": "# Master's Project Repository\n\n## Description\nThis repository contains Python scripts for various image inpainting techniques implemented as part of my Master's project. The implemented techniques include Curvature-Driven Diffusions (CDD), Nonlinear Diffusion Filter (NDF), Total Variation (TV) inpainting, and optimization scripts for tuning parameters.\n\n\n## Portfolio.pdf\n\nPlease take the time to read the \"Final Portfolio.pdf\" the sum and results of this research project of mine. \n\n\n## Installation\n1. Clone the repository:\n   ```\n   git clone https://github.com/kizer/Masters-project.git\n   ```\n\n2. Ensure you have the necessary dependencies installed:\n   - numpy\n   - scipy\n   - matplotlib\n   - scikit-image\n   - opencv-python\n   - Pillow\n\n3. Run the scripts using a Python environment.\n\n### CDD Inpainting\n- File: `CDD.py`\n- Function: `cdd_inpainting(image, mask, g, iterations=100, tau=0.1)`\n- Parameters:\n  - `image`: 2D numpy array representing the grayscale image.\n  - `mask`: 2D boolean numpy array where True indicates missing pixels to inpaint.\n  - `g`: Function that modifies diffusion based on curvature.\n  - `iterations`: Number of iterations to run the inpainting process.\n  - `tau`: Time step size.\n\n### NDF Inpainting\n- File: `Nonlinear_diff.py`\n- Function: `nonlinearDiffusionFilter(image, iterations=5, lamb=1.0, tau=0.125)`\n- Parameters:\n  - `image`: Input image for inpainting.\n  - `iterations`: Number of iterations for the filtering process.\n  - `lamb`: Lambda parameter for diffusivity.\n  - `tau`: Time step size.\n\n### TV Inpainting\n- File: `TV.py`\n- Function: `TV(input_img, lambda_val, mask, T, dt)`\n- Parameters:\n  - `input_img`: Input image for inpainting.\n  - `lambda_val`: Lambda value for the TV inpainting.\n  - `mask`: Mask indicating regions to inpaint.\n  - `T`: Total time for the inpainting process.\n  - `dt`: Time step size.\n\n### Optimization Scripts\n- Files: `Optimization_CDD.py`, `Optimization_NDF.py`, `Optimization_TV.py`\n- These scripts perform optimization to find the best parameters for inpainting techniques.\n\n### Video Inpainting\n- Files: `VIdeo-TV.py`, `Video.py`\n- These scripts perform inpainting on a sequence of images.\n\nFor more detailed usage instructions, refer to the comments in the respective Python scripts.\n\n## Project Files\nThe repository contains multiple Python scripts implementing various image inpainting techniques, each with specific functions and usage instructions. Kindly refer to the individual scripts for detailed information on each technique and how to use them.\n\n---\n\nFeel free to explore and experiment with the provided scripts for image inpainting using different techniques and optimization approaches. If you encounter any issues or have any questions, please feel free to reach out."
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\TV.py",
        "name": "TV.py",
        "content": "import numpy as np\nfrom scipy import ndimage\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\ndef TV(input_img, lambda_val, mask, T, dt):\n    # Initialize variables\n    i, j = input_img.shape\n    mask = (mask == 0).astype(float)\n    input_img = input_img.astype(float)\n    input_img = mask * input_img \n    u = input_img.copy()\n    iterations = 0\n\n    # Uncomment to display initial image\n    '''\n    plt.figure()\n    plt.title('Inpainting...')\n    plt.imshow(u, cmap='gray')\n    plt.show(block=False)\n    '''\n    \n    # Perform Total Variation denoising\n    for t in np.arange(0, T, dt):\n        # Calculate gradients\n        u_x = np.gradient(u, axis=1)\n        u_y = np.gradient(u, axis=0)\n        N = np.sum(np.sqrt(u_x**2 + u_y**2))\n\n        u_xx = np.gradient(u_x, axis=1)\n        u_yy = np.gradient(u_y, axis=0)\n        u_xy = np.gradient(u_x, axis=0)\n\n        # Compute energy functional\n        deltaE = -(u_xx * u_y**2 - 2*u_x * u_y * u_xy + u_yy * u_x**2) / ( 0.1 + (u_x**2 + u_y**2)**(3/2)) + 2 * mask * (lambda_val * (u - input_img))\n\n        # Update image\n        u = dt * (-deltaE ) + u \n        #print(N)\n        iterations += 1\n        '''\n        # Uncomment to display intermediate results\n        if iterations % 100 == 0:\n            plt.clf()\n            plt.imshow(u / 255, cmap='gray')\n            plt.title(f'Inpainting: {iterations} iterations...')\n            plt.draw()\n            plt.pause(0.001)\n        '''\n    \n    return u, N"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\VIdeo-TV.py",
        "name": "VIdeo-TV.py",
        "content": "import os\nimport numpy as np\nimport cv2\nfrom skimage import img_as_ubyte, io, color\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom TV import *\n\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    # Create a mask with a square region in the middle\n    mask = np.zeros(image.shape, dtype=bool)\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Function to save images to a folder\ndef save_image(image, lambda_value, folder_path):\n    # Save the inpainted image with a specific filename based on lambda value\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n    filename = f\"inpainted_image_lambda_{lambda_value:.3f}.png\"\n    file_path = os.path.join(folder_path, filename)\n    io.imsave(file_path, image)\n    print(f\"Saved image: {file_path}\")\n\n# Parameters\nlambda_values = np.linspace(0.1, 1.0, 50)  # 50 values between 0.1 and 1.0\nT = 2500\ndt = 1\n\n# Load the images\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with a small square in the middle\nmask = generate_square_mask(gray_image, square_size=50)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Folder to save the output images\noutput_folder = r\"C:\\Users\\kizer\\Master_code\\output_image\"\n\n# Set up progress bar for lambda iterations\nfor lambda_val in tqdm(lambda_values, desc='Lambda Iterations'):\n    # Inpaint the image using Total Variation method\n    inpainted_image, _ = TV(masked_image, lambda_val, mask, T, dt)\n    \n    # Normalize the inpainted image to the range [0, 1]\n    inpainted_image_normalized = (inpainted_image - np.min(inpainted_image)) / (np.max(inpainted_image) - np.min(inpainted_image))\n    \n    # Convert the inpainted image back to uint8 format for saving\n    inpainted_image_uint8 = img_as_ubyte(inpainted_image_normalized)\n    \n    # Save the inpainted image with lambda value in the filename\n    save_image(inpainted_image_uint8, lambda_val, output_folder)"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Video.py",
        "name": "Video.py",
        "content": "import os\nimport numpy as np\nimport cv2\nfrom skimage import img_as_ubyte, io, color\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom CDD import *\n\n# Function to generate a mask with a small square in the middle\ndef generate_square_mask(image, square_size=50):\n    # Calculate the coordinates for the center of the image\n    center_x, center_y = image.shape[1] // 2, image.shape[0] // 2\n    half_size = square_size // 2\n    # Create a mask with a square in the middle\n    mask = np.zeros(image.shape, dtype=bool)\n    mask[center_y - half_size:center_y + half_size, center_x - half_size:center_x + half_size] = True\n    return mask\n\n# Function to save images to a folder\ndef save_image(image, tau_value, folder_path):\n    # Create the folder if it does not exist\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n    # Generate the filename based on tau value\n    filename = f\"inpainted_image_tau_{tau_value:.3f}.png\"\n    file_path = os.path.join(folder_path, filename)\n    # Save the image\n    io.imsave(file_path, image)\n    print(f\"Saved image: {file_path}\")\n\n# Parameters\ntau_values = np.linspace(0.01, 0.5, 50)  # 50 values between 0.01 and 0.5\n\n# Load the images\noriginal = io.imread(r\"C:\\Users\\kizer\\Master_code\\input_0_zoom.png\")\ngray_image = color.rgb2gray(original)\n\n# Generate a mask with a small square in the middle\nmask = generate_square_mask(gray_image, square_size=50)\n\n# Apply the mask to the grayscale image (set masked areas to 0)\nmasked_image = np.copy(gray_image)\nmasked_image[mask] = 0\n\n# Folder to save the output images\noutput_folder = r\"C:\\Users\\kizer\\Master_code\\output_images\"\n\n# Set up progress bar for tau iterations\nfor tau in tqdm(tau_values, desc='Tau Iterations'):\n    # Define the g function based on curvature \n    p = 1  \n    g = lambda s: s**p\n\n    # Inpaint the image\n    inpainted_image = cdd_inpainting(masked_image, mask, g, iterations=2500, tau=tau)\n\n    # Normalize the inpainted image to the range [0, 1]\n    inpainted_image_normalized = (inpainted_image - np.min(inpainted_image)) / (np.max(inpainted_image) - np.min(inpainted_image))\n\n    # Convert the inpainted image back to uint8 format for saving\n    inpainted_image_uint8 = img_as_ubyte(inpainted_image_normalized)\n\n    # Save the inpainted image\n    save_image(inpainted_image_uint8, tau, output_folder)"
    },
    {
        "path": "C:\\Users\\kizer\\Master's project\\Total-variation-Inpainting\\README.md",
        "name": "README.md",
        "content": "# Total Variation Inpainting\n\nInpainting is the process of restoring damaged images. Ultimately the goal is to present the image as it was created. The method implemented is based on heat equation and its goal is to minimize the energy in the given image. Indeed, high energy means that we have important disparities in the image.\n\nIf you're interested, you can find out more in my report.\n\n## How to use\n\n1. git clone https://github.com/StephaneSobucki/Total-variation-Inpainting\n2. run main.m script in Matlab\n3. Load your image\n4. Set parameters for inpainting (T: total time, dt: timestep, lambda: fidelity coefficient)\n5. Create mask\n6. Inpaint\n\n## Dependencies\n\nTo draw the mask, you have to install the Image Processing Toolbox.\n\n## Example\n\n![create_mask](example/create_mask.png)\n\n![inpaint](example/inpainting.png)\n"
    }
]